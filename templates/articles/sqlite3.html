{% include 'dsa/header.html' %}
<div class="wrapper">
<div>
    <h1>SQLite3</h1>
    <p>SQLite3 is a package in python used to interact with an sqlite database. Sqlite database is a relational database that is extremely light. It is a single file present on the computer and ends with the .db extension.
        It is a serverless database. The file also contains a standard way to communicate with it using SQL that is embedded within it. Any programming language that supports sqlite can interact with the database.
    </p>
    <p>Relational databases are structured databases that store files in tables and establish relationships between the tables. A popular way to interact with this data is through Structured Query Language(SQL). <b>SQL</b>
    is a declarative language used to create, query and manage the data contained in this database. A declarative language states what is to be accomplished rather than how it is should be accomplished.
    </p>

    <h2>Storage Classes and Datatypes</h2>
    <p>There are five storage classes in sqlite. This means every value in sqlite has one of five storage classes:</p>
    <ul>
        <li><b>NULL.</b> The value is a NULL value.</li>
        <li><b>INTEGER.</b> The value is a signed integer, stored in 0, 1, 2, 3, 4, 6 or 8 bytes depending on the magnitude of the value.</li>
        <li><b>REAL.</b> The value is a floating point value, stored as an 8-byte IEEE floating point number.</li>
        <li><b>TEXT.</b> The value is a text string, stored using the database encoding(UTF-8, UTF-16BE or UTF-16LE).</li>
        <li><b>BLOB. </b> The value is a blob of data, stored exactly as it was input.</li>
    </ul>
    <p><b>Note: </b> Although storage classes are used interchangeably with datatypes, they are quite different. They make a difference on disk but when read into memory, they may be the same as datatypes.</p>
    <p>More on datatypes later.</p>
</div>

<div>
    <h2>Structuring a Database with SQL</h2>
    <p>Let's get right into it. The basic concept is to structure a table in a database into rows and columns. Each row is a record. Each column or field is a property of the record.
        The basic structure or placeholder consists of an empty table with several columns that describe the features of the records that will populate the table. An example would be a person.
        A person or user is a record that has unique properties such as name, address, age, height, weight and etc. Each property of a user such as name, height, etc is a column. 
    </p>
    <p>
        Each column has a title which defines the unique data that will be stored in it. Eg name. All our records(people) that will be stored in the table will have names. They will have addresses and so on.
        Each title(column or field) will have a type. The name is of type string(varchar in the case of sql), age will be of type int.
    </p>
    <p>
        Among the columns or properties of each record, there is usually a unique identifier. It is called a primary key. This is similar to a key in a <b>python dictionary</b>. The primary key can be specified when creating a table. 
        One column or field is usually chosen to be the primary field. It is usually the column with data that is unique across all records. Email addresses for example could be used as unique identifiers in our example.
    </p>
<pre>
CREATE TABLE user (
    first_name TEXT,
    last_name TEXT,
    email_address TEXT NOT NULL,
    address TEXT,
    phone_number INT,
    birthday TEXT
)
</pre>
<p>
    The above command creates a table(a placeholder) for our data. It is used to create a table where records can be added one row at a time.
    The fields are defined above. 
</p>
</div>

<div>
    <h2>One-to-Many Relationships</h2>
    <p>A <b>one-to-many</b> relationship is used when one record in a table can be associated with many records in another table. To continue with our example, imagine if our users had cars. They are rich.
    A user could have several cars. So let us create a car table with all the properties of the cars.</p>
<pre>
CREATE TABLE car (
    car_name TEXT,
    car_make TEXT,
    car_model TEXT,
    bought_on TEXT,
)
</pre>
<p>Below are two tables in our sqlite database. Each table has a couple of records added to it.</p>
</div>


<div>
    <!-- Draw tables to upload and explain your example here -->
</div>

<div>
    <h2>Sqlite3 Package API and its Description</h2>
    <p></p>
</div>
<div>
    <h2>SQLite Datatypes and Column Affinity</h2>
    <p>Each column in a database has one of the resulting affinities:</p>
    <ul>
        <li>TEXT</li>
        <li>NUMERIC</li>
        <li>INTEGER</li>
        <li>REAL</li>
        <li>BLOB</li>
    </ul>
    <p><b>What is column Affinity?</b> Sqlite is not as rigid as other sql databases. A column can store any type of data. In other SQL databases, a column converts data into the specified database before attempting to store it.</p>
    <p>In Sqlite, the data storage classes are recommended. This is the column affinity. The sqlite database engine recommends the data storage class and this supports compatibility with other sql databases.</p>
    <p>As a result, these affinities are used to create tables and columns.</p>

    <p>Let's briefly discuss the datatype and the resulting Type Affinity briefly.</p>
    <h3>INTEGER Column Affinity</h3>
    <ul>
        The datatypes associated with the Integer column affinity are:
        <li>INT</li>
        <li>INTEGER</li>
        <li>TINYINT</li>
        <li>SMALLINT</li>
        <li>MEDIUMINT</li>
        <li>BIGINT</li>
        <li>UNSIGNED BIG INT</li>
        <li>INT2</li>
        <li>INT8</li>
    </ul>

    <h3>TEXT Storage Class</h3>
    <ul>

    </ul>

    <h3>SQLite Datetime</h3>
    <p>Sqlite does not have a storage class set aside for storing dates and/or times. Instead, the built-in date and time functions of SQlite are capable of storing dates and times as 
        TEXT, REAL, or INTEGER values:
    </p>
    <ul>
        <li><b>TEXT </b>as ISO8601</li>
        <li><b>REAL </b> as julian numbers. The number of days since noon in Greenwich on November 24, 4714 B.C. according to the proleptic Gregorian calendar.</li>
        <li><b>INTEGER </b> as Unix Time, the number of seconds since 1970-01-01 00:00:00 UTC</li>
    </ul>
    <p>A little about SQL datetime. Sqlite supports 5 date and time functions.</p>
    <ul>
        <li>date(timestring, modifiers...) This returns the date in this format: YYYY-MM-DD</li>
        <li>time(timestring, modifiers...) This returns the time as HH:MM:SS</li>
        <li>datetime(timestring, modifiers...) This returns YYYY-MM-DD HH:MM:SS</li>
        <li>julianday(timestring, modifiers...) This returns the number of days since noon in Greenwich on November 24, 4714 B.C.</li>
        <li>strftime(timestring, modifiers...) This returns the date formatted according to the format string specified as the first argument
            formatted.
        </li>
    </ul>

    <h3>SQLite Boolean</h3>
    <p>Just like the datatime datatype, Sqlite does not support boolean datatype.</p>
</div>

</div>
{% include 'dsa/footer.html' %}